# TEP Module 4 (Revised): Workflow State Management

## Context: Why This Revision Exists

The original TEP Module 4 spec called for building a custom StateManager with dependency analysis, state persistence, and retry logic. After implementation, we discovered that trigger.dev already provides all these features. This revised spec leverages the platform instead of rebuilding it.

**Key Changes:**
- Use trigger.dev's built-in state management (not custom StateManager)
- Enforce JSON-safe types at compile time (not runtime)
- Focus on workflow logic (not infrastructure)
- Clarified module boundaries and ID generation responsibilities
- Updated to use actual trigger.dev v3 API patterns

## 1. Your Role and Mission

You are an expert TypeScript developer with a strong background in distributed systems and workflow orchestration. Your mission is to implement the **Workflow State Management** module using trigger.dev's native capabilities. This module leverages trigger.dev's built-in state management, dependency resolution, and durability features rather than reimplementing them.

## 2. Core Architectural Principles

* **Platform-Native**: Use trigger.dev's built-in state management, not custom implementations
* **JSON-Safe by Design**: All data must be JSON-serializable at compile time using our constrained Zod schemas
* **Idempotent Operations**: Leverage trigger.dev's idempotency guarantees
* **Observable by Default**: Use trigger.dev's dashboard for debugging and monitoring

## 3. Module Boundaries and Interactions

### 3.1. Module Responsibilities

The TEP system consists of three primary execution modules with clear boundaries:

**Module 2 (HTTP Action Executor)**:
- Executes individual HTTP actions
- Handles retries, timeouts, and error recovery for HTTP calls
- Returns structured action results
- Does NOT manage state or dependencies

**Module 3 (Plan Orchestrator)**:
- Coordinates the execution of complete plans
- Manages action dependencies and execution order
- Delegates actual HTTP execution to Module 2
- Requests state management from Module 4

**Module 4 (State Manager - This Module)**:
- Provides durable state storage for execution progress
- Tracks action statuses and results
- Enables recovery from failures
- Wraps trigger.dev's native state in a consistent interface

### 3.2. Data Flow

```
Module 3 (Orchestrator)
    |
    ├─> Module 4 (State Manager) - Tracks execution state
    |
    └─> Module 2 (HTTP Executor) - Performs actions
```

## 4. ID Generation and Ownership

### 4.1. ID Responsibilities

**Important**: Module 4 does NOT generate IDs. All IDs come from upstream systems:

- **Plan IDs**: Generated by the system that creates execution plans
- **Action IDs**: Defined within the plan structure
- **Execution IDs**: Use trigger.dev's `ctx.run.id` for tracking individual executions

### 4.2. ID Usage Example

```typescript
// IDs come from the plan, not generated by us
export const executeWorkflow = task({
  id: 'execute-workflow',
  run: async ({ plan }: { plan: ExecutionPlan }, { ctx }) => {
    // Use trigger.dev's run ID as our execution ID
    const executionId = ctx.run.id;
    
    // Plan and action IDs are already in the plan
    console.log(`Executing plan ${plan.id} as execution ${executionId}`);
    
    // We track state using these provided IDs
    const state = {
      executionId, // From trigger.dev
      planId: plan.id, // From upstream
      actions: plan.actions.map(a => ({
        actionId: a.id, // From plan
        status: 'pending'
      }))
    };
  }
});
```

## 5. Your Complete Work Package: Workflow State Management Specifications

Implement workflow orchestration using trigger.dev's native patterns. The package name for this module is `workflow-state`.

### 5.1. Purpose & Responsibilities
* Define workflows that execute plans using trigger.dev tasks
* Leverage trigger.dev's automatic state persistence and recovery
* Use trigger.dev's built-in dependency management for action ordering
* Provide type-safe interfaces for workflow execution

### 5.2. Public Interface

```typescript
// packages/workflow-state/interface.ts
import { z } from '@rainmaker/schema'; // Our JSON-safe Zod
import type { ExecutionPlan, ExecutionState, ActionResult } from '@rainmaker/schema';

// Workflow definition using trigger.dev patterns
export interface WorkflowExecutor {
  // Start a new workflow execution
  execute(plan: ExecutionPlan): Promise<WorkflowExecution>;
  
  // Query workflow state (via trigger.dev API)
  getState(executionId: string): Promise<WorkflowState | null>;
  
  // Get specific action result
  getActionResult(executionId: string, actionId: string): Promise<ActionResult | null>;
}

// Type-safe workflow state
export const WorkflowStateSchema = z.object({
  executionId: z.string(),
  planId: z.string(),
  status: z.enum(['pending', 'running', 'completed', 'failed', 'cancelled']),
  startedAt: z.dateString(), // Using our JSON-safe helper
  completedAt: z.dateString().optional(),
  results: z.record(z.string(), ActionResultSchema)
});

export type WorkflowState = z.infer<typeof WorkflowStateSchema>;

// Type-safe action result (no `any` types!)
export const ActionResultSchema = z.object({
  actionId: z.string(),
  status: z.enum(['completed', 'failed', 'skipped']),
  output: z.record(z.string(), z.unknown()).optional(), // Structured data, not `any`
  error: z.object({
    message: z.string(),
    code: z.string().optional()
  }).optional(),
  startedAt: z.dateString(),
  completedAt: z.dateString(),
  duration: z.number() // milliseconds
});

export type ActionResult = z.infer<typeof ActionResultSchema>;
```

## 6. Why We Still Need StateManager Interface

### 6.1. The Apparent Redundancy

You might wonder: "If trigger.dev has native state management, why do we need a StateManager interface at all?"

### 6.2. The Answer: Interface Consistency

Modules 2 and 3 expect a specific state management interface. While trigger.dev provides excellent state persistence, it doesn't provide the exact API that our other modules expect. The StateManager acts as an adapter:

```typescript
// What Module 3 expects
interface StateManager {
  initializeState(plan: ExecutionPlan): Promise<void>;
  updateActionStatus(executionId: string, actionId: string, status: ActionStatus): Promise<void>;
  getExecutionState(executionId: string): Promise<ExecutionState | null>;
}

// What trigger.dev provides
task({
  run: async (payload, { ctx }) => {
    // State is implicit in ctx.run
    await ctx.run('update-state', async () => { /* ... */ });
  }
});

// Our StateManager bridges the gap
class TriggerDevStateManager implements StateManager {
  async updateActionStatus(executionId: string, actionId: string, status: ActionStatus) {
    // Use triggerAndWait to update state in the workflow
    const result = await updateActionStatusTask.triggerAndWait({
      executionId,
      actionId,
      status
    });
    
    if (!result.ok) {
      throw new Error(`Failed to update action status: ${result.error}`);
    }
  }
}
```

### 6.3. Benefits of the Adapter Pattern

1. **Decoupling**: Modules 2 & 3 don't need to know about trigger.dev
2. **Testability**: Can mock StateManager interface without trigger.dev
3. **Flexibility**: Could switch workflow engines without changing Module 2 & 3
4. **Type Safety**: Enforce our schema constraints at the boundary

## 7. Implementation Using Trigger.dev v3 API

### 7.1. Correct API Patterns

Based on actual trigger.dev v3 documentation, here are the correct patterns:

```typescript
// packages/workflow-state/executor.ts
import { task } from '@trigger.dev/sdk/v3';
import { z } from '@rainmaker/schema';

// Define a task with retry configuration
export const executeWorkflow = task({
  id: 'execute-workflow',
  queue: { 
    name: 'workflows',
    concurrencyLimit: 10 
  },
  retry: {
    maxAttempts: 3,
    factor: 2,
    minTimeoutInMs: 1000,
    maxTimeoutInMs: 10000
  },
  run: async ({ plan }: { plan: ExecutionPlan }, { ctx }) => {
    // Use ctx.run.id for execution tracking
    const executionId = ctx.run.id;
    
    // State is automatically initialized and persisted by trigger.dev
    const state = await ctx.run('init-state', async () => ({
      executionId,
      planId: plan.id,
      status: 'running' as const,
      startedAt: new Date().toISOString(),
      results: {}
    }));

    // Execute actions with automatic dependency resolution
    const results = await executeActionsWithDependencies(
      plan.actions,
      ctx
    );

    // Return final state (automatically persisted)
    return {
      ...state,
      status: determineStatus(results),
      completedAt: new Date().toISOString(),
      results
    };
  }
});

// Using triggerAndWait for synchronous execution
export const updateActionStatusTask = task({
  id: 'update-action-status',
  run: async ({ executionId, actionId, status }) => {
    // Update state logic here
    return { success: true };
  }
});

// Client code using triggerAndWait
export class TriggerDevWorkflowExecutor implements WorkflowExecutor {
  async execute(plan: ExecutionPlan): Promise<WorkflowExecution> {
    // triggerAndWait returns a result object with .ok property
    const result = await executeWorkflow.triggerAndWait({ plan });
    
    if (!result.ok) {
      throw new Error(`Workflow execution failed: ${result.error}`);
    }
    
    return {
      executionId: result.data.executionId,
      status: result.data.status
    };
  }
  
  async getState(executionId: string): Promise<WorkflowState | null> {
    // Query state using a dedicated task
    const result = await getWorkflowStateTask.triggerAndWait({ executionId });
    
    if (!result.ok) {
      console.error(`Failed to get state: ${result.error}`);
      return null;
    }
    
    return result.data;
  }
}
```

### 7.2. Important trigger.dev v3 Patterns

1. **No Idempotency with triggerAndWait**: The `idempotencyKey` option is not available with `triggerAndWait`
2. **Result Checking**: Always check `result.ok` before accessing `result.data`
3. **Retry Configuration**: Set at task definition, not at trigger time
4. **Context Usage**: Use `ctx.run.id` for execution tracking

## 8. Execution Tracking with ctx.run.id

### 8.1. Using trigger.dev's Run ID

```typescript
export const executeActionTask = task({
  id: 'execute-action',
  run: async ({ action, executionContext }, { ctx }) => {
    // ctx.run.id is unique for this task execution
    const taskRunId = ctx.run.id;
    
    // But we track using the parent execution ID
    const { executionId } = executionContext;
    
    console.log(`Task ${taskRunId} executing action ${action.id} for execution ${executionId}`);
    
    // Store results keyed by our execution ID, not task run ID
    await ctx.run('store-result', async () => {
      return storeActionResult(executionId, action.id, result);
    });
  }
});
```

### 8.2. Maintaining Execution Context

```typescript
// Parent workflow maintains the execution ID
export const planWorkflow = task({
  id: 'plan-workflow',
  run: async ({ plan }, { ctx }) => {
    const executionId = ctx.run.id; // This becomes our execution ID
    
    // Pass execution context to child tasks
    for (const action of plan.actions) {
      await executeActionTask.triggerAndWait({
        action,
        executionContext: {
          executionId, // Pass parent execution ID
          planId: plan.id
        }
      });
    }
  }
});
```

## 9. Acceptance Criteria (Revised)

* **WORKFLOW-001**: Workflows must use trigger.dev tasks for all state management
* **WORKFLOW-002**: All data structures must use JSON-safe Zod schemas (no `any`, `unknown`, `Date`, etc.)
* **WORKFLOW-003**: Action dependencies are resolved using trigger.dev's task orchestration
* **WORKFLOW-004**: State persistence is handled entirely by trigger.dev (no custom StorageProvider)
* **WORKFLOW-005**: Retry logic uses trigger.dev's built-in retry configuration at task level
* **WORKFLOW-006**: Result checking uses `.ok` pattern for all `triggerAndWait` calls
* **WORKFLOW-007**: Circular dependencies are detected at workflow definition time
* **WORKFLOW-008**: All workflows are observable via trigger.dev dashboard
* **WORKFLOW-009**: StateManager interface is provided for Modules 2 & 3 compatibility
* **WORKFLOW-010**: Execution tracking uses trigger.dev's `ctx.run.id`

## 10. Required Dependencies

### 10.1. JSON-Safe Zod
All schemas must use our constrained Zod from `@rainmaker/schema`:

```typescript
import { z, assertJsonSerializable } from '@rainmaker/schema';

// ✅ Good - JSON-safe
const ConfigSchema = z.object({
  timeout: z.number(),
  retries: z.number(),
  createdAt: z.dateString() // ISO string, not Date
});

// ❌ Bad - Not JSON-safe
const BadSchema = z.object({
  createdAt: z.date(),     // Not allowed
  data: z.any(),           // Not allowed
  metadata: z.unknown()    // Not allowed
});
```

### 10.2. Trigger.dev SDK
```typescript
import { task, wait } from '@trigger.dev/sdk/v3';
```

## 11. Migration from Custom State Manager

If you have existing code using the custom StateManager:

```typescript
// Old way (custom state manager)
const stateManager = new StateManagerImpl(storageProvider);
await stateManager.initializeState(plan);
await stateManager.updateActionStatus(executionId, actionId, 'running');

// New way (trigger.dev native with adapter)
const stateManager = new TriggerDevStateManager();
// Same interface, but backed by trigger.dev
await stateManager.initializeState(plan);
await stateManager.updateActionStatus(executionId, actionId, 'running');
```

## 12. Benefits of This Approach

1. **Less Code**: No custom state management, persistence, or retry logic
2. **More Reliable**: Battle-tested platform handles edge cases
3. **Better Observability**: Built-in dashboard, logs, and metrics
4. **Automatic Recovery**: State survives process crashes and restarts
5. **Type Safety**: JSON-safe schemas prevent serialization errors
6. **Interface Stability**: Other modules don't need to change

## 13. Your Final Deliverable

Produce the following files within the `packages/workflow-state/` directory:

* `packages/workflow-state/interface.ts`: Type-safe interfaces using JSON-safe Zod
* `packages/workflow-state/executor.ts`: Workflow implementation using trigger.dev
* `packages/workflow-state/state-manager.ts`: StateManager adapter for Module 2 & 3 compatibility
* `packages/workflow-state/patterns.ts`: Common patterns for dependency resolution
* `packages/workflow-state/__tests__/workflows.test.ts`: Tests using trigger.dev test utilities
* `packages/workflow-state/migration.md`: Guide for migrating from custom state manager

## 14. Key Learnings Applied

1. **Don't rebuild platform features**: Trigger.dev already provides state management
2. **Enforce constraints at compile time**: JSON-safe Zod prevents runtime errors
3. **Use the platform's patterns**: `ctx.run()`, `triggerAndWait()` with `.ok` checking
4. **Let the platform handle complexity**: Retries, idempotency, persistence
5. **Provide adapters for interface stability**: StateManager wraps trigger.dev for other modules
6. **Respect ID ownership**: We track IDs, not generate them

Remember: We're not building infrastructure, we're building business logic on top of a robust platform.