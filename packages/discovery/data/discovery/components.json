{
  "sample-googleoauthprovider": {
    "metadata": {
      "id": "sample-googleoauthprovider",
      "name": "GoogleOAuthProvider",
      "description": "React component for Google OAuth authentication",
      "category": "auth",
      "technical": {
        "language": "typescript",
        "framework": "react",
        "dependencies": [
          "react"
        ],
        "patterns": [
          "authentication",
          "oauth",
          "context",
          "hooks"
        ]
      }
    },
    "code": {
      "raw": "\nimport React, { createContext, useContext, useState, useEffect } from 'react';\n\ninterface GoogleAuthConfig {\n  clientId: string;\n  redirectUri?: string;\n  scopes?: string[];\n}\n\ninterface GoogleUser {\n  id: string;\n  email: string;\n  name: string;\n  picture: string;\n}\n\ninterface GoogleAuthContextType {\n  user: GoogleUser | null;\n  signIn: () => Promise<void>;\n  signOut: () => Promise<void>;\n  loading: boolean;\n}\n\nconst GoogleAuthContext = createContext<GoogleAuthContextType | null>(null);\n\nexport const useGoogleAuth = () => {\n  const context = useContext(GoogleAuthContext);\n  if (!context) {\n    throw new Error('useGoogleAuth must be used within GoogleAuthProvider');\n  }\n  return context;\n};\n\nexport const GoogleAuthProvider: React.FC<{\n  config: GoogleAuthConfig;\n  children: React.ReactNode;\n}> = ({ config, children }) => {\n  const [user, setUser] = useState<GoogleUser | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    // Initialize Google Auth\n    const initGoogleAuth = async () => {\n      try {\n        await window.google.accounts.id.initialize({\n          client_id: config.clientId,\n          callback: handleCredentialResponse,\n        });\n        setLoading(false);\n      } catch (error) {\n        console.error('Failed to initialize Google Auth:', error);\n        setLoading(false);\n      }\n    };\n\n    initGoogleAuth();\n  }, [config.clientId]);\n\n  const handleCredentialResponse = (response: any) => {\n    // Decode JWT token\n    const payload = JSON.parse(atob(response.credential.split('.')[1]));\n    setUser({\n      id: payload.sub,\n      email: payload.email,\n      name: payload.name,\n      picture: payload.picture,\n    });\n  };\n\n  const signIn = async () => {\n    setLoading(true);\n    try {\n      window.google.accounts.id.prompt();\n    } catch (error) {\n      console.error('Sign in failed:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const signOut = async () => {\n    setUser(null);\n    window.google.accounts.id.disableAutoSelect();\n  };\n\n  return (\n    <GoogleAuthContext.Provider value={{ user, signIn, signOut, loading }}>\n      {children}\n    </GoogleAuthContext.Provider>\n  );\n};\n          "
    }
  },
  "sample-jwtauthmiddleware": {
    "metadata": {
      "id": "sample-jwtauthmiddleware",
      "name": "JWTAuthMiddleware",
      "description": "Express middleware for JWT token authentication",
      "category": "auth",
      "technical": {
        "language": "typescript",
        "framework": "express",
        "dependencies": [
          "jsonwebtoken",
          "express"
        ],
        "patterns": [
          "authentication",
          "jwt",
          "middleware",
          "async"
        ]
      }
    },
    "code": {
      "raw": "\nimport jwt from 'jsonwebtoken';\nimport { Request, Response, NextFunction } from 'express';\n\ninterface JWTConfig {\n  secret: string;\n  algorithm?: jwt.Algorithm;\n  expiresIn?: string;\n  issuer?: string;\n}\n\ninterface AuthenticatedRequest extends Request {\n  user?: any;\n}\n\nexport class JWTAuthMiddleware {\n  private config: JWTConfig;\n\n  constructor(config: JWTConfig) {\n    this.config = {\n      algorithm: 'HS256',\n      expiresIn: '24h',\n      ...config,\n    };\n  }\n\n  generateToken(payload: object): string {\n    return jwt.sign(payload, this.config.secret, {\n      algorithm: this.config.algorithm,\n      expiresIn: this.config.expiresIn,\n      issuer: this.config.issuer,\n    });\n  }\n\n  verifyToken = (req: AuthenticatedRequest, res: Response, next: NextFunction) => {\n    const authHeader = req.headers.authorization;\n    \n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      return res.status(401).json({ error: 'No token provided' });\n    }\n\n    const token = authHeader.substring(7);\n\n    try {\n      const decoded = jwt.verify(token, this.config.secret, {\n        algorithms: [this.config.algorithm!],\n        issuer: this.config.issuer,\n      });\n      \n      req.user = decoded;\n      next();\n    } catch (error) {\n      if (error instanceof jwt.TokenExpiredError) {\n        return res.status(401).json({ error: 'Token expired' });\n      } else if (error instanceof jwt.JsonWebTokenError) {\n        return res.status(401).json({ error: 'Invalid token' });\n      } else {\n        return res.status(500).json({ error: 'Token verification failed' });\n      }\n    }\n  };\n}\n          "
    }
  },
  "sample-stripepaymentprocessor": {
    "metadata": {
      "id": "sample-stripepaymentprocessor",
      "name": "StripePaymentProcessor",
      "description": "TypeScript class for handling Stripe payments",
      "category": "payments",
      "technical": {
        "language": "typescript",
        "dependencies": [
          "stripe"
        ],
        "patterns": [
          "payments",
          "async",
          "webhooks",
          "api-calls"
        ]
      }
    },
    "code": {
      "raw": "\nimport Stripe from 'stripe';\n\ninterface PaymentConfig {\n  secretKey: string;\n  webhookSecret?: string;\n  apiVersion?: Stripe.LatestApiVersion;\n}\n\nexport class StripePaymentProcessor {\n  private stripe: Stripe;\n  private webhookSecret?: string;\n\n  constructor(config: PaymentConfig) {\n    this.stripe = new Stripe(config.secretKey, {\n      apiVersion: config.apiVersion || '2023-10-16',\n    });\n    this.webhookSecret = config.webhookSecret;\n  }\n\n  async createPaymentIntent(options: {\n    amount: number;\n    currency: string;\n    customerId?: string;\n    metadata?: Record<string, string>;\n  }): Promise<Stripe.PaymentIntent> {\n    try {\n      const paymentIntent = await this.stripe.paymentIntents.create({\n        amount: options.amount,\n        currency: options.currency,\n        customer: options.customerId,\n        metadata: options.metadata,\n        payment_method_types: ['card'],\n        automatic_payment_methods: {\n          enabled: true,\n        },\n      });\n\n      return paymentIntent;\n    } catch (error) {\n      throw new Error(`Failed to create payment intent: ${error.message}`);\n    }\n  }\n\n  async createCustomer(email: string, name?: string): Promise<Stripe.Customer> {\n    try {\n      const customer = await this.stripe.customers.create({\n        email,\n        name,\n      });\n\n      return customer;\n    } catch (error) {\n      throw new Error(`Failed to create customer: ${error.message}`);\n    }\n  }\n}\n          "
    }
  }
}