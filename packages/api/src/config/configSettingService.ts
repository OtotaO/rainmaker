import { PrismaClient } from '.prisma/client';
import { ConfigSettingSchema } from '../../../schema/src/types/configSetting'; // Import from schema package
import { CustomError } from '../lib/custom-error';
import { logger } from '../lib/logger';
import { z } from 'zod';

/**
 * Error class for ConfigSetting operations
 */
export class ConfigSettingError extends CustomError {}

/**
 * Service for managing application configuration settings
 * This service handles the creation, retrieval, and management of config settings
 * with proper validation and error handling
 */
export class ConfigSettingService {
  /**
   * Creates a new ConfigSettingService instance
   * @param prisma - The PrismaClient instance for database operations
   */
  constructor(private prisma: PrismaClient) {}

  /**
   * Creates a new configuration setting
   * @param data - The configuration setting data to create
   * @returns The created configuration setting
   * @throws ConfigSettingError if creation fails
   */
  async createConfigSetting(data: Omit<z.infer<typeof ConfigSettingSchema>, 'id' | 'lastModified'>) {
    try {
      logger.debug('Creating config setting', { key: data.key });
      
      // Validate with Zod schema
      const validated = ConfigSettingSchema.parse({
        ...data,
        lastModified: new Date()
      });

      // Handle non-string values by stringifying them if not encrypted
      let valueToStore: string;
      if (typeof validated.value !== 'string' && !validated.isEncrypted) {
        valueToStore = JSON.stringify(validated.value);
      } else {
        valueToStore = String(validated.value);
      }

      // Check if setting with same key already exists
      const existing = await this.prisma.configSetting.findUnique({
        where: { key: validated.key }
      });

      if (existing) {
        throw new ConfigSettingError(`Config setting with key '${validated.key}' already exists`);
      }

      // Create in database
      const result = await this.prisma.configSetting.create({
        data: {
          ...validated,
          value: valueToStore,
          // Ensure these fields are properly set
          id: validated.id, // Will be undefined and generated by Prisma
          lastModified: validated.lastModified
        }
      });

      logger.info('Config setting created successfully', { key: result.key });
      
      // Parse stored value back to original type if not encrypted
      let parsedResult = { 
        ...result,
        // Convert null to undefined to match schema
        description: result.description ?? undefined,
        category: result.category ?? undefined
      };
      
      if (!result.isEncrypted && result.value) {
        try {
          // Only attempt to parse if it looks like JSON
          if (result.value.startsWith('{') || 
              result.value.startsWith('[') || 
              result.value === 'true' || 
              result.value === 'false' || 
              !isNaN(Number(result.value))) {
            parsedResult.value = JSON.parse(result.value);
          }
        } catch (e) {
          // If parsing fails, keep the original string value
          logger.debug('Failed to parse config value back to JSON', { error: e });
        }
      }

      return parsedResult as z.infer<typeof ConfigSettingSchema>;
    } catch (error) {
      if (error instanceof ConfigSettingError) {
        throw error; // Re-throw our custom errors directly
      }
      
      // Log and wrap other errors
      const err = error as Error;
      logger.error('Failed to create config setting', { 
        error: err.message, 
        stack: err.stack,
        key: data.key 
      });
      
      throw new ConfigSettingError('Failed to create config setting', error);
    }
  }

  /**
   * Retrieves a configuration setting by key
   * @param key - The key of the setting to retrieve
   * @returns The configuration setting or null if not found
   */
  async getConfigSetting(key: string): Promise<z.infer<typeof ConfigSettingSchema> | null> {
    try {
      const setting = await this.prisma.configSetting.findUnique({
        where: { key }
      });

      if (!setting) {
        return null;
      }

      // Convert Prisma model to schema-compatible object
      const settingResult = {
        ...setting,
        // Convert null to undefined to match schema
        description: setting.description ?? undefined,
        category: setting.category ?? undefined
      };
      
      // Parse stored value back to original type if not encrypted
      if (!setting.isEncrypted && setting.value) {
        try {
          // Only attempt to parse if it looks like JSON
          if (setting.value.startsWith('{') || 
              setting.value.startsWith('[') || 
              setting.value === 'true' || 
              setting.value === 'false' || 
              !isNaN(Number(setting.value))) {
            settingResult.value = JSON.parse(setting.value);
          }
        } catch (e) {
          // If parsing fails, keep the original string value
          logger.debug('Failed to parse config value back to JSON', { error: e });
        }
      }

      return settingResult as z.infer<typeof ConfigSettingSchema>;
    } catch (error) {
      const err = error as Error;
      logger.error('Failed to get config setting', { 
        error: err.message, 
        stack: err.stack,
        key 
      });
      
      throw new ConfigSettingError('Failed to get config setting', error);
    }
  }
}
